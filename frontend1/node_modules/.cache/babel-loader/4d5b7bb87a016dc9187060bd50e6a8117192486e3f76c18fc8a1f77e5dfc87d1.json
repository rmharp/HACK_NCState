{"ast":null,"code":"import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState, useEffect } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const gl = useThree(state => state.gl);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        totalFrames.current = numberOfFrames;\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    _spriteTexture.encoding = THREE.sRGBEncoding;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n    }\n    return sprites;\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n\n  // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n  // NOTE: only available for WebGLRenderer\n  useEffect(() => {\n    if ('initTexture' in gl) {\n      const array = Array.isArray(spriteTexture) ? spriteTexture : [spriteTexture];\n      array.forEach(gl.initTexture);\n    }\n  }, [gl, spriteTexture]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\nexport { calculateAspectRatio, getFirstItem, useSpriteLoader };","map":{"version":3,"names":["THREE","TextureLoader","useThree","useLoader","React","useState","useEffect","getFirstItem","param","Array","isArray","keys","Object","w","h","calculateAspectRatio","width","height","factor","v","adaptedHeight","aspect","adaptedWidth","scaleX","scaleY","currentMaxScale","finalMaxScaleW","Math","min","finalMaxScaleH","Vector3","useSpriteLoader","input","json","animationNames","numberOfFrames","onLoad","state","viewport","gl","spriteDataRef","useRef","totalFrames","aspectFactor","spriteData","setSpriteData","spriteTexture","setSpriteTexture","Texture","textureLoader","spriteObj","setSpriteObj","useLayoutEffect","loadJsonAndTextureAndExecuteCallback","parseSpriteData","loadStandaloneSprite","clear","loadJsonAndTexture","textureUrl","jsonUrl","Promise","resolve","load","then","texture","callback","jsonPromise","fetch","response","texturePromise","all","_spriteTexture","image","frameWidth","frameHeight","current","frames","meta","version","size","scale","parseInt","toString","i","push","frame","x","y","rotated","trimmed","spriteSourceSize","sourceSize","parseFrames","length","encoding","sRGBEncoding","sprites","data","delimiters","innerKey","value","frameData","sourceWidth","sourceHeight","toLowerCase","indexOf","array","forEach","initTexture","preload","url"],"sources":["/Users/riley/Hack_NCState/frontend/node_modules/@react-three/drei/core/useSpriteLoader.js"],"sourcesContent":["import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState, useEffect } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const gl = useThree(state => state.gl);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        totalFrames.current = numberOfFrames;\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    _spriteTexture.encoding = THREE.sRGBEncoding;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n    }\n    return sprites;\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n\n  // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n  // NOTE: only available for WebGLRenderer\n  useEffect(() => {\n    if ('initTexture' in gl) {\n      const array = Array.isArray(spriteTexture) ? spriteTexture : [spriteTexture];\n      array.forEach(gl.initTexture);\n    }\n  }, [gl, spriteTexture]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { calculateAspectRatio, getFirstItem, useSpriteLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}